// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under $JAVA_SRC_PATH dir
/*
Simple DirectMedia Layer
Java source code (C) 2009-2012 Sergii Pylypenko
  
This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:
  
1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

package pandora.uae4all.sdl;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.Semaphore;
import java.util.zip.CRC32;
import java.util.zip.CheckedInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import retrobox.content.SaveStateInfo;
import retrobox.keyboard.KeyboardMappingUtils;
import retrobox.utils.GamepadInfoDialog;
import retrobox.utils.ImmersiveModeSetter;
import retrobox.utils.ListOption;
import retrobox.utils.RetroBoxDialog;
import retrobox.utils.RetroBoxUtils;
import retrobox.utils.SaveStateSelectorAdapter;
import retrobox.v2.pandora.uae4all.sdl.R;
import retrobox.vinput.GamepadDevice;
import retrobox.vinput.GamepadMapping.Analog;
import retrobox.vinput.Mapper;
import retrobox.vinput.QuitHandler;
import retrobox.vinput.QuitHandler.QuitHandlerCallback;
import retrobox.vinput.VirtualEvent.MouseButton;
import retrobox.vinput.VirtualEventDispatcher;
import retrobox.vinput.overlay.ExtraButtons;
import retrobox.vinput.overlay.ExtraButtonsController;
import retrobox.vinput.overlay.ExtraButtonsView;
import retrobox.vinput.overlay.Overlay;
import retrobox.vinput.overlay.OverlayExtra;
import retrobox.vinput.overlay.OverlayGamepadController;
import retrobox.vinput.overlay.OverlayGamepadView;
import xtvapps.core.AndroidFonts;
import xtvapps.core.Callback;
import xtvapps.core.SimpleCallback;
import xtvapps.core.Utils;
import xtvapps.core.content.KeyValue;
import android.app.Activity;
import android.app.NativeActivity;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Color;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.SystemClock;
import android.text.InputType;
import android.text.SpannedString;
import android.util.Log;
import android.view.Display;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnKeyListener;
import android.view.ViewGroup;
import android.view.ViewTreeObserver;
import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.view.Window;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.FrameLayout;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

public class MainActivity extends Activity
{ 	
	
	private static final String LOGTAG = MainActivity.class.getSimpleName();
	
	private static final String KEY_AUDIO_FILTER = "audioFilter";
	private static final String KEY_STEREO_SEPARATION = "stereoSeparation";
	
	public static Mapper mapper;
	static VirtualEventDispatcher vinputDispatcher;
	
	static OverlayGamepadController overlayGamepadController;
	static OverlayGamepadView overlayGamepadView;
	static ExtraButtonsController extraButtonsController;
	static ExtraButtonsView extraButtonsView;
	static boolean canOpenRetroBoxMenu = false;
	
	public static final Overlay overlay = new Overlay();
	private boolean aliased;
	private boolean canSwap = false;
	private GamepadInfoDialog gamepadInfoDialog;
	
	private static int saveSlot = 0;
	
	@Override
	protected void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);

		//if( android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2 )
		//	setRequestedOrientation(Globals.HorizontalOrientation ? ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE : ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT);
		if( android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.GINGERBREAD )
			setRequestedOrientation(Globals.HorizontalOrientation ? ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE : ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT);
		else
			setRequestedOrientation(Globals.HorizontalOrientation ? ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE : ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);

		instance = this;
		
		// fullscreen mode
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
				WindowManager.LayoutParams.FLAG_FULLSCREEN);
		
		if(Globals.InhibitSuspend)
			getWindow().setFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON,
					WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);

		setImmersiveMode();
		
		Globals.KeepAspectRatioDefaultSetting = true;
		Globals.KeepAspectRatio = getIntent().getBooleanExtra("keepAspect", true);
		
		vinputDispatcher = new VirtualInputDispatcher();
		mapper = new Mapper(getIntent(), vinputDispatcher);
		Mapper.initGestureDetector(this);

		overlayGamepadController = new OverlayGamepadController();
		overlayGamepadView = new OverlayGamepadView(this, overlay);
		
		extraButtonsController = new ExtraButtonsController();
		extraButtonsView = new ExtraButtonsView(this);
		
		aliased = getIntent().getBooleanExtra("linearFilter", true);
		canSwap = getIntent().getBooleanExtra("canSwap", false);
	
		
		Log.i("SDL", "libSDL: Creating startup screen");
		_layout = new LinearLayout(this);
		_layout.setOrientation(LinearLayout.VERTICAL);
		_layout.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.FILL_PARENT));
		_layout2 = new LinearLayout(this);
		_layout2.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));

		final Semaphore loadedLibraries = new Semaphore(0);

		if( Globals.StartupMenuButtonTimeout > 0 )
		{
/*			_btn = new Button(this);
			_btn.setEnabled(false);
			_btn.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
			_btn.setText(getResources().getString(R.string.device_change_cfg));
			class onClickListener implements View.OnClickListener
			{
					public MainActivity p;
					onClickListener( MainActivity _p ) { p = _p; }
					public void onClick(View v)
					{
						setUpStatusLabel();
						Log.i("SDL", "libSDL: User clicked change phone config button");
						loadedLibraries.acquireUninterruptibly();
						SettingsMenu.showConfig(p, false);
					}
			};
			_btn.setOnClickListener(new onClickListener(this));

			_layout2.addView(_btn);*/
		}
          
		_layout.addView(_layout2);

/*		ImageView img = new ImageView(this);     

		img.setScaleType(ImageView.ScaleType.FIT_CENTER);
		try
		{
			img.setImageDrawable(Drawable.createFromStream(getAssets().open("logo.png"), "logo.png"));
		}
		catch(Exception e)
		{
			img.setImageResource(R.drawable.publisherlogo);
		}
		img.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.FILL_PARENT));
		_layout.addView(img);
*/		
		_videoLayout = new FrameLayout(this);
		_videoLayout.addView(_layout);

		_ad = new Advertisement(this);
		if( _ad.getView() != null )
		{
			_videoLayout.addView(_ad.getView());
			_ad.getView().setLayoutParams(new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.BOTTOM | Gravity.RIGHT));
		}
		
		setContentView(_videoLayout);

		class Callback implements Runnable
		{
			MainActivity p;
			Callback( MainActivity _p ) { p = _p; }
			public void run()
			{
				try {
					Thread.sleep(200);
				} catch( InterruptedException e ) {};

				if(p.mAudioThread == null)
				{
					Log.i("SDL", "libSDL: Loading libraries");
					p.LoadLibraries();
					p.mAudioThread = new AudioThread(p);
					
					loadAudioSettings();
					
					boolean isInvertedRGB = getIntent().getBooleanExtra("invertRGB", false);
					Log.d("SDL", "libSDL: set isInvertedRGB = " + isInvertedRGB);
	                DemoRenderer.nativeSetInvertRGB(isInvertedRGB);
	                
					Log.i("SDL", "libSDL: Loading settings");
					final Semaphore loaded = new Semaphore(0);
					class Callback2 implements Runnable
					{
						public MainActivity Parent;
						public void run()
						{   
							Settings.Load(Parent);
							Globals.VideoLinearFilter = aliased;
							loaded.release();
							loadedLibraries.release();
							if( _btn != null )
								_btn.setEnabled(true);
						}
					}
					
					
					Callback2 cb = new Callback2();
					cb.Parent = p;
					p.runOnUiThread(cb);
					loaded.acquireUninterruptibly();
					if(!Globals.CompatibilityHacksStaticInit)
						p.LoadApplicationLibrary(p);
				}

				if( !Settings.settingsChanged )
				{
					if( Globals.StartupMenuButtonTimeout > 0 )
					{
						Log.i("SDL", "libSDL: " + String.valueOf(Globals.StartupMenuButtonTimeout) + "-msec timeout in startup screen");
						try {
							Thread.sleep(Globals.StartupMenuButtonTimeout);
						} catch( InterruptedException e ) {};
					}
					if( Settings.settingsChanged )
						return;
					Log.i("SDL", "libSDL: Timeout reached in startup screen, process with downloader");
					p.startDownloader();
				}
			}
		};
		(new Thread(new Callback(this))).start();
		if( Globals.CreateService )
		{
			Intent intent = new Intent(this, DummyService.class);
			startService(intent);
		}
	}
	
	public void setUpStatusLabel()
	{
		MainActivity Parent = this; // Too lazy to rename
		if( Parent._btn != null )
		{
			Parent._layout2.removeView(Parent._btn);
			Parent._btn = null;
		}
		if( Parent._tv == null )
		{
			//Get the display so we can know the screen size
			Display display = getWindowManager().getDefaultDisplay(); 
			int width = display.getWidth();
			int height = display.getHeight();
			Parent._tv = new TextView(Parent);
			Parent._tv.setMaxLines(2); // To show some long texts on smaller devices
			Parent._tv.setMinLines(2); // Otherwise the background picture is getting resized at random, which does not look good
			Parent._tv.setText(R.string.init);
			// Padding is a good idea because if the display device is a TV the edges might be cut off
			Parent._tv.setPadding((int)(width * 0.1), (int)(height * 0.1), (int)(width * 0.1), 0);
			Parent._layout2.addView(Parent._tv);
		}
	}

	private void setImmersiveMode() {
		ImmersiveModeSetter.get().setImmersiveMode(getWindow(), isStableLayout());
	}
	
	private boolean isStableLayout() {
		return Mapper.hasGamepads();
	}
	
	public void startDownloader()
	{
		Log.i("SDL", "libSDL: Starting data downloader");
		class Callback implements Runnable
		{
			public MainActivity Parent;
			public void run()
			{
				setUpStatusLabel();
				Log.i("SDL", "libSDL: Starting downloader");
				if( Parent.downloader == null )
					Parent.downloader = new DataDownloader(Parent, Parent._tv);
			}
		}
		Callback cb = new Callback();
		cb.Parent = this;
		this.runOnUiThread(cb);
	}

	public void initSDL()
	{
		(new Thread(new Runnable()
		{
			public void run()
			{
				//int tries = 30;
				while( isCurrentOrientationHorizontal() != Globals.HorizontalOrientation )
				{
					Log.i("SDL", "libSDL: Waiting for screen orientation to change - the device is probably in the lockscreen mode");
					try {
						Thread.sleep(500);
					} catch( Exception e ) {}
					/*
					tries--;
					if( tries <= 0 )
					{
						Log.i("SDL", "libSDL: Giving up waiting for screen orientation change");
						break;
					}
					*/
					if( _isPaused )
					{
						Log.i("SDL", "libSDL: Application paused, cancelling SDL initialization until it will be brought to foreground");
						return;
					}
				}
				runOnUiThread(new Runnable()
				{
					public void run()
					{
						initSDLInternal();
					}
				});
			}
		})).start();
	}

	private void initSDLInternal()
	{
		if(sdlInited)
			return;
		Log.i("SDL", "libSDL: Initializing video and SDL application");
		
		sdlInited = true;
		_videoLayout.removeView(_layout);
		if( _ad.getView() != null )
			_videoLayout.removeView(_ad.getView());
		_layout = null;
		_layout2 = null;
		_btn = null;
		_tv = null;
		_inputManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
		_videoLayout = new FrameLayout(this);
		SetLayerType.get().setLayerType(_videoLayout);
		setContentView(_videoLayout);
		mGLView = new DemoGLSurfaceView(this);
		SetLayerType.get().setLayerType(mGLView);
		_videoLayout.addView(mGLView);
		mGLView.setFocusableInTouchMode(true);
		mGLView.setFocusable(true);
		mGLView.requestFocus();
		if( _ad.getView() != null )
		{
			_videoLayout.addView(_ad.getView());
			_ad.getView().setLayoutParams(new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.TOP | Gravity.RIGHT));
		}
		// Receive keyboard events
		DimSystemStatusBar.get().dim(_videoLayout);
		DimSystemStatusBar.get().dim(mGLView);
		
		setupGamepadOverlay();
		
		getLayoutInflater().inflate(R.layout.modal_dialog_list, _videoLayout);
		AndroidFonts.setViewFont(findViewById(R.id.txtDialogListTitle), RetroBoxUtils.FONT_DEFAULT_M);
		canOpenRetroBoxMenu = true;
		
        getLayoutInflater().inflate(R.layout.modal_dialog_gamepad, _videoLayout);
        AndroidFonts.setViewFont(findViewById(R.id.txtGamepadInfoTop), RetroBoxUtils.FONT_DEFAULT_M);
        AndroidFonts.setViewFont(findViewById(R.id.txtGamepadInfoBottom), RetroBoxUtils.FONT_DEFAULT_M);

        gamepadInfoDialog = new GamepadInfoDialog(this);
        gamepadInfoDialog.loadFromIntent(getIntent());
        
        getLayoutInflater().inflate(R.layout.modal_dialog_savestates, _videoLayout);
	}

	private boolean needsOverlay() {
		return Mapper.mustDisplayOverlayControllers();
	}
	
	private int lastWidth = 0;
	private int lastHeight = 0;
	
	private void setupGamepadOverlay() {
		ViewTreeObserver observer = mGLView.getViewTreeObserver();
		observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
			@Override
			public void onGlobalLayout() {
		    	int w = mGLView.getWidth();
		    	int h = mGLView.getHeight();
		    	if (lastWidth == w && lastHeight == h) return;
		    	
		    	lastWidth  = w;
		    	lastHeight = h;
		    	
				if (needsOverlay()) {
			    	String overlayConfig = getIntent().getStringExtra("OVERLAY");
					float alpha = getIntent().getFloatExtra("OVERLAY_ALPHA", 0.8f);
			    	if (overlayConfig!=null) overlay.init(overlayConfig, w, h, alpha);
				}
		
		    	Log.d("REMAP", "addExtraButtons : " + getIntent().getStringExtra("buttons"));
		        ExtraButtons.initExtraButtons(MainActivity.this, getIntent().getStringExtra("buttons"), w, h, true);
			}
		});

		if (needsOverlay()) {
			 overlayGamepadView.addToLayout(_videoLayout);
			 overlayGamepadView.showPanel();
		}
		 
		extraButtonsView.addToLayout(_videoLayout);
		extraButtonsView.hidePanel();
	}

	@Override
	protected void onPause() {

		pauseEmulation();
		_isPaused = true;
		//if( _ad.getView() != null )
		//	_ad.getView().onPause();
		super.onPause();
	}

	@Override
	protected void onResume() {
		super.onResume();
		ImmersiveModeSetter.postImmersiveMode(new Handler(), getWindow(), isStableLayout());
		
		resumeEmulation();
		_isPaused = false;
	}

	private void pauseEmulation() {
		if( downloader != null )
		{
			synchronized( downloader )
			{
				downloader.setStatusField(null);
			}
		}
		if( mGLView != null ) {
			mGLView.onPause();
			while (!mGLView.isWaiting()) {
				try {
					Thread.sleep(200);
				} catch (InterruptedException e) {}
			}
		}		
		Log.d(LOGTAG, "Emulation Paused");
	}
	
	private void resumeEmulation() {
		if( mGLView != null )
		{
			mGLView.onResume();
			while (!mGLView.isResumed()) {
				try {
					Thread.sleep(200);
				} catch (InterruptedException e) {}
			}
		}
		else
		if( downloader != null )
		{
			synchronized( downloader )
			{
				downloader.setStatusField(_tv);
				if( downloader.DownloadComplete )
				{
					initSDL();
				}
			}
		}
		Log.d(LOGTAG, "Emulation Resumed");
	}

	@Override
	public void onWindowFocusChanged (boolean hasFocus) {
		super.onWindowFocusChanged(hasFocus);
		Log.i("SDL", "libSDL: onWindowFocusChanged: " + hasFocus + " - sending onPause/onResume");
		if (hasFocus == false)
			onPause();
		else {
			onResume();
	        new Handler().postDelayed(new Runnable(){
				@Override
				public void run() {
					setImmersiveMode();
				}
			}, 5000);
		}
		/*
		if (hasFocus == false) {
			synchronized(textInput) {
				// Send 'SDLK_PAUSE' (to enter pause mode) to native code:
				DemoRenderer.nativeTextInput( 19, 19 );
			}
		}
		*/
	}
	
	public boolean isPaused()
	{
		return _isPaused;
	}

	@Override
	protected void onDestroy()
	{
		if( downloader != null )
		{
			synchronized( downloader )
			{
				downloader.setStatusField(null);
			}
		}
		if( mGLView != null )
			mGLView.exitApp();
		super.onDestroy();
		try{
			Thread.sleep(2000); // The event is sent asynchronously, allow app to save it's state, and call exit() itself.
		} catch (InterruptedException e) {}
		System.exit(0);
	}

	public void showScreenKeyboardWithoutTextInputField()
	{
		if( !keyboardWithoutTextInputShown )
		{
			keyboardWithoutTextInputShown = true;
			_inputManager.toggleSoftInput(InputMethodManager.SHOW_FORCED, 0);
			_inputManager.showSoftInput(mGLView, InputMethodManager.SHOW_FORCED);
			getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
		}
		else
		{
			keyboardWithoutTextInputShown = false;
			getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);
			_inputManager.hideSoftInputFromWindow(mGLView.getWindowToken(), 0);
			DimSystemStatusBar.get().dim(_videoLayout);
			DimSystemStatusBar.get().dim(mGLView);
		}
	}
	
	public void toastMessage(final String message) {
		Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
	}

	public void showScreenKeyboard(final String oldText, boolean sendBackspace)
	{
		if(Globals.CompatibilityHacksTextInputEmulatesHwKeyboard)
		{
			showScreenKeyboardWithoutTextInputField();
			return;
		}
		if(_screenKeyboard != null)
			return;
		class simpleKeyListener implements OnKeyListener
		{
			MainActivity _parent;
			boolean sendBackspace;
			simpleKeyListener(MainActivity parent, boolean sendBackspace) { _parent = parent; this.sendBackspace = sendBackspace; };
			public boolean onKey(View v, int keyCode, KeyEvent event)
			{
				if ((event.getAction() == KeyEvent.ACTION_UP) && (
					keyCode == KeyEvent.KEYCODE_ENTER ||
					keyCode == KeyEvent.KEYCODE_BACK ||
					keyCode == KeyEvent.KEYCODE_MENU ||
					keyCode == KeyEvent.KEYCODE_BUTTON_A ||
					keyCode == KeyEvent.KEYCODE_BUTTON_B ||
					keyCode == KeyEvent.KEYCODE_BUTTON_X ||
					keyCode == KeyEvent.KEYCODE_BUTTON_Y ||
					keyCode == KeyEvent.KEYCODE_BUTTON_1 ||
					keyCode == KeyEvent.KEYCODE_BUTTON_2 ||
					keyCode == KeyEvent.KEYCODE_BUTTON_3 ||
					keyCode == KeyEvent.KEYCODE_BUTTON_4 ))
				{
					_parent.hideScreenKeyboard();
					return true;
				}
				if (keyCode == KeyEvent.KEYCODE_DEL || keyCode == KeyEvent.KEYCODE_CLEAR)
				{
					if (sendBackspace && event.getAction() == KeyEvent.ACTION_UP)
					{
						synchronized(textInput) {
							DemoRenderer.nativeTextInput( 8, 0 ); // Send backspace to native code
						}
					}
					// EditText deletes two characters at a time, here's a hacky fix
					if (event.getAction() == KeyEvent.ACTION_DOWN && (event.getFlags() | KeyEvent.FLAG_SOFT_KEYBOARD) != 0)
					{
						EditText t = (EditText) v;
						int start = t.getSelectionStart();  //get cursor starting position
						int end = t.getSelectionEnd();      //get cursor ending position
						if ( start < 0 )
							return true;
						if ( end < 0 || end == start )
						{
							start --;
							if ( start < 0 )
								return true;
							end = start + 1;
						}
						t.setText(t.getText().toString().substring(0, start) + t.getText().toString().substring(end));
						t.setSelection(start);
						return true;
					}
				}
				//Log.i("SDL", "Key " + keyCode + " flags " + event.getFlags() + " action " + event.getAction());
				return false;
			}
		};
		_screenKeyboard = new EditText(this);
		// This code does not work
		/*
		_screenKeyboard.setMaxLines(100);
		ViewGroup.LayoutParams layout = _screenKeyboard.getLayoutParams();
		if( layout != null )
		{
			layout.width = ViewGroup.LayoutParams.FILL_PARENT;
			layout.height = ViewGroup.LayoutParams.FILL_PARENT;
			_screenKeyboard.setLayoutParams(layout);
		}
		_screenKeyboard.setGravity(android.view.Gravity.BOTTOM | android.view.Gravity.LEFT);
		*/
		String hint = _screenKeyboardHintMessage;
		_screenKeyboard.setHint(hint != null ? hint : getString(R.string.text_edit_click_here));
		_screenKeyboard.setText(oldText);
		_screenKeyboard.setSelection(_screenKeyboard.getText().length());
		_screenKeyboard.setOnKeyListener(new simpleKeyListener(this, sendBackspace));
		_screenKeyboard.setBackgroundColor(Color.BLACK); // Full opaque - do not show semi-transparent edit box, it's confusing
		_screenKeyboard.setTextColor(Color.WHITE); // Just to be sure about gamma
		if( isRunningOnOUYA() )
			_screenKeyboard.setPadding(100, 100, 100, 100); // Bad bad HDMI TVs all have cropped borders
		_videoLayout.addView(_screenKeyboard);
		//_screenKeyboard.setKeyListener(new TextKeyListener(TextKeyListener.Capitalize.NONE, false));
		_screenKeyboard.setInputType(InputType.TYPE_CLASS_TEXT);
		_screenKeyboard.setFocusableInTouchMode(true);
		_screenKeyboard.setFocusable(true);
		_screenKeyboard.requestFocus();
		_inputManager.showSoftInput(_screenKeyboard, InputMethodManager.SHOW_IMPLICIT);
		getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
		// Hack to try to force on-screen keyboard
		final EditText keyboard = _screenKeyboard;
		keyboard.postDelayed( new Runnable()
			{
				public void run()
				{
					keyboard.requestFocus();
					//_inputManager.toggleSoftInput(InputMethodManager.SHOW_FORCED, 0);
					_inputManager.showSoftInput(keyboard, InputMethodManager.SHOW_FORCED);
					// Hack from Stackoverflow, to force text input on Ouya
					keyboard.dispatchTouchEvent(MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN , 0, 0, 0));
					keyboard.dispatchTouchEvent(MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_UP , 0, 0, 0));
					keyboard.postDelayed( new Runnable()
					{
						public void run()
						{
							keyboard.setSelection(keyboard.getText().length());
						}
					}, 100 );
				}
			}, 500 );
	};

	public void hideScreenKeyboard()
	{
		if( keyboardWithoutTextInputShown )
			showScreenKeyboardWithoutTextInputField();

		if(_screenKeyboard == null)
			return;

		synchronized(textInput)
		{
			String text = _screenKeyboard.getText().toString();
			for(int i = 0; i < text.length(); i++)
			{
				DemoRenderer.nativeTextInput( (int)text.charAt(i), (int)text.codePointAt(i) );
			}
		}
		DemoRenderer.nativeTextInputFinished();
		_inputManager.hideSoftInputFromWindow(_screenKeyboard.getWindowToken(), 0);
		_videoLayout.removeView(_screenKeyboard);
		_screenKeyboard = null;
		mGLView.setFocusableInTouchMode(true);
		mGLView.setFocusable(true);
		mGLView.requestFocus();
		DimSystemStatusBar.get().dim(_videoLayout);
		DimSystemStatusBar.get().dim(mGLView);

		_videoLayout.postDelayed( new Runnable()
			{
				public void run()
				{
					DimSystemStatusBar.get().dim(_videoLayout);
					DimSystemStatusBar.get().dim(mGLView);
				}
			}, 500 );
	};

	public boolean isScreenKeyboardShown()
	{
		return _screenKeyboard != null;
	};
	
	public void setScreenKeyboardHintMessage(String s)
	{
		_screenKeyboardHintMessage = s;
		//Log.i("SDL", "setScreenKeyboardHintMessage: " + (_screenKeyboardHintMessage != null ? _screenKeyboardHintMessage : getString(R.string.text_edit_click_here)));
		runOnUiThread(new Runnable()
		{
			public void run()
			{
				if( _screenKeyboard != null )
				{
					String hint = _screenKeyboardHintMessage;
					_screenKeyboard.setHint(hint != null ? hint : getString(R.string.text_edit_click_here));
				}
			}
		} );
	}

	final static int ADVERTISEMENT_POSITION_RIGHT = -1;
	final static int ADVERTISEMENT_POSITION_BOTTOM = -1;
	final static int ADVERTISEMENT_POSITION_CENTER = -2;

	public void setAdvertisementPosition(int x, int y)
	{
		
		if( _ad.getView() != null )
		{
			final FrameLayout.LayoutParams layout = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
			layout.gravity = 0;
			layout.leftMargin = 0;
			layout.topMargin = 0;
			if( x == ADVERTISEMENT_POSITION_RIGHT )
				layout.gravity |= Gravity.RIGHT;
			else if ( x == ADVERTISEMENT_POSITION_CENTER )
				layout.gravity |= Gravity.CENTER_HORIZONTAL;
			else
			{
				layout.gravity |= Gravity.LEFT;
				layout.leftMargin = x;
			}
			if( y == ADVERTISEMENT_POSITION_BOTTOM )
				layout.gravity |= Gravity.BOTTOM;
			else if ( x == ADVERTISEMENT_POSITION_CENTER )
				layout.gravity |= Gravity.CENTER_VERTICAL;
			else
			{
				layout.gravity |= Gravity.TOP;
				layout.topMargin = y;
			}
			class Callback implements Runnable
			{
				public void run()
				{
					_ad.getView().setLayoutParams(layout);
				}
			};
			runOnUiThread(new Callback());
		}
	}
	public void setAdvertisementVisible(final int visible)
	{
		if( _ad.getView() != null )
		{
			class Callback implements Runnable
			{
				public void run()
				{
					if( visible == 0 )
						_ad.getView().setVisibility(View.GONE);
					else
						_ad.getView().setVisibility(View.VISIBLE);
				}
			}
			runOnUiThread(new Callback());
		}
	}

	public void getAdvertisementParams(int params[])
	{
		for( int i = 0; i < 5; i++ )
			params[i] = 0;
		if( _ad.getView() != null )
		{
			params[0] = (_ad.getView().getVisibility() == View.VISIBLE) ? 1 : 0;
			FrameLayout.LayoutParams layout = (FrameLayout.LayoutParams) _ad.getView().getLayoutParams();
			params[1] = layout.leftMargin;
			params[2] = layout.topMargin;
			params[3] = _ad.getView().getMeasuredWidth();
			params[4] = _ad.getView().getMeasuredHeight();
		}
	}
	public void requestNewAdvertisement()
	{
		if( _ad.getView() != null )
		{
			class Callback implements Runnable
			{
				public void run()
				{
					_ad.requestNewAd();
				}
			}
			runOnUiThread(new Callback());
		}
	}

	
	@Override
	public boolean dispatchKeyEvent(KeyEvent event) {

		if (!RetroBoxDialog.isDialogVisible(this) && mGLView != null
//			&& !customKeyboard.isVisible()
			&& !KeyboardMappingUtils.isKeyMapperVisible()) {

			int keyCode     = event.getKeyCode();
			boolean isDown  = event.getAction() == KeyEvent.ACTION_DOWN;
			if (mapper.handleKeyEvent(this, event, keyCode, isDown)) return true;
		}

		return super.dispatchKeyEvent(event);
	}

	@Override
	public boolean onKeyDown(int keyCode, final KeyEvent event)
	{
		if (RetroBoxDialog.isDialogVisible(this)) {
			return RetroBoxDialog.onKeyDown(this, keyCode, event);
		}
		if (mapper.isSystemKey(event, keyCode)) return super.onKeyDown(keyCode, event);
		
		if(_screenKeyboard != null) {
			_screenKeyboard.onKeyDown(keyCode, event);
		} else if( mGLView != null ) {
			if( mGLView.nativeKey( keyCode, 1, event.getUnicodeChar() ) == 0 )
				return super.onKeyDown(keyCode, event);
		} else if( keyListener != null ) {
			keyListener.onKeyEvent(keyCode);
		} else if( _btn != null )
			return _btn.onKeyDown(keyCode, event);
		
		return true;
	}
	
	@Override
	public boolean onKeyUp(int keyCode, final KeyEvent event)
	{
		if (RetroBoxDialog.isDialogVisible(this)) {
			return RetroBoxDialog.onKeyUp(this, keyCode, event);
		}
		
		if (mapper.isSystemKey(event, keyCode)) return super.onKeyUp(keyCode, event);
		
		if(_screenKeyboard != null) {
			_screenKeyboard.onKeyUp(keyCode, event);
		} else if( mGLView != null ) {
			if( mGLView.nativeKey( keyCode, 0, event.getUnicodeChar() ) == 0 )
				return super.onKeyUp(keyCode, event);
			if( keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_MENU )
			{
				DimSystemStatusBar.get().dim(_videoLayout);
				DimSystemStatusBar.get().dim(mGLView);
			}
		} else if( _btn != null ) {
			return _btn.onKeyUp(keyCode, event);
		}
		return true;
	}
	
	public static void swapMouseJoystick() {}


	@Override
	public boolean onKeyMultiple(int keyCode, int repeatCount, final KeyEvent event)
	{
		if (RetroBoxDialog.isDialogVisible(this)) {
			return super.onKeyMultiple(keyCode, repeatCount, event);
		}
		
		// International text input
		if( mGLView != null && event.getCharacters() != null )
		{
			for(int i = 0; i < event.getCharacters().length(); i++ )
			{
				mGLView.nativeKey( event.getKeyCode(), 1, event.getCharacters().codePointAt(i) );
				mGLView.nativeKey( event.getKeyCode(), 0, event.getCharacters().codePointAt(i) );
			}
			return true;
		}
		return false;
	}

	@Override
	public boolean dispatchTouchEvent(final MotionEvent ev) {
		if (RetroBoxDialog.isDialogVisible(this)) {
			return super.dispatchTouchEvent(ev);
		}

    	if (overlayGamepadView.isVisible() && overlayGamepadController.onTouchEvent(ev)) {
    		// Log.d("TOUCH", "dispatched to gamepadController");
    		if (Overlay.requiresRedraw) {
        		Overlay.requiresRedraw = false;
    			overlayGamepadView.invalidate();
    		}
    		return true;
    	}
    	if (extraButtonsView.isVisible() && extraButtonsController.onTouchEvent(ev)) {
    		if (OverlayExtra.requiresRedraw) {
    			OverlayExtra.requiresRedraw = false;
    			extraButtonsView.invalidate();
    		}
    		return true;
    	}
    	
    	mapper.onTouchEvent(ev);
    	
		//Log.i("SDL", "dispatchTouchEvent: " + ev.getAction() + " coords " + ev.getX() + ":" + ev.getY() );
		if(_screenKeyboard != null)
			_screenKeyboard.dispatchTouchEvent(ev);
		else
		if( _ad.getView() != null && // User clicked the advertisement, ignore when user moved finger from game screen to advertisement or touches screen with several fingers
			((ev.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN ||
			(ev.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP) &&
			_ad.getView().getLeft() <= (int)ev.getX() &&
			_ad.getView().getRight() > (int)ev.getX() &&
			_ad.getView().getTop() <= (int)ev.getY() &&
			_ad.getView().getBottom() > (int)ev.getY() )
			return super.dispatchTouchEvent(ev);
		else
		if(mGLView != null)
			mGLView.onTouchEvent(ev);
		else
		if( _btn != null )
			return _btn.dispatchTouchEvent(ev);
		else
		if( touchListener != null )
			touchListener.onTouchEvent(ev);
		return true;
	}
	
	@Override
	public boolean dispatchGenericMotionEvent (MotionEvent ev)
	{
		//Log.i("SDL", "dispatchGenericMotionEvent: " + ev.getAction() + " coords " + ev.getX() + ":" + ev.getY() );
		// This code fails to run for Android 1.6, so there will be no generic motion event for Andorid screen keyboard
		/*
		if(_screenKeyboard != null)
			_screenKeyboard.dispatchGenericMotionEvent(ev);
		else
		*/
		
		if (RetroBoxDialog.isDialogVisible(this)) {
			return super.dispatchGenericMotionEvent(ev);
		}
		
		if(mGLView != null)
			mGLView.onGenericMotionEvent(ev);
		return true;
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig)
	{
		super.onConfigurationChanged(newConfig);
		// Do nothing here
	}
	
	public void setText(final String t)
	{
		class Callback implements Runnable
		{
			MainActivity Parent;
			public SpannedString text;
			public void run()
			{
				Parent.setUpStatusLabel();
				if(Parent._tv != null)
					Parent._tv.setText(text);
			}
		}
		Callback cb = new Callback();
		cb.text = new SpannedString(t);
		cb.Parent = this;
		this.runOnUiThread(cb);
	}

	public void showTaskbarNotification()
	{
		showTaskbarNotification("SDL application paused", "SDL application", "Application is paused, click to activate");
	}

	// Stolen from SDL port by Mamaich
	public void showTaskbarNotification(String text0, String text1, String text2)
	{
		NotificationManager NotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
		Intent intent = new Intent(this, MainActivity.class);
		PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, Intent.FLAG_ACTIVITY_NEW_TASK);
		Notification n = new Notification(R.drawable.icon, text0, System.currentTimeMillis());
		//n.setLatestEventInfo(this, text1, text2, pendingIntent);
		NotificationManager.notify(NOTIFY_ID, n);
	}

	public void hideTaskbarNotification()
	{
		NotificationManager NotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
		NotificationManager.cancel(NOTIFY_ID);
	}
	
	public void LoadLibraries()
	{
		try
		{
			if(Globals.NeedGles2)
				System.loadLibrary("GLESv2");
			Log.i("SDL", "libSDL: loaded GLESv2 lib");
		}
		catch ( UnsatisfiedLinkError e )
		{
			Log.i("SDL", "libSDL: Cannot load GLESv2 lib");
		}

		// Load all libraries
		try
		{
			for(String l : Globals.AppLibraries)
			{
				try
				{
					String libname = System.mapLibraryName(l);
					File libpath = new File(getFilesDir().getAbsolutePath() + "/../lib/" + libname);
					Log.i("SDL", "libSDL: loading lib " + libpath.getAbsolutePath());
					System.load(libpath.getPath());
				}
				catch( UnsatisfiedLinkError e )
				{
					Log.i("SDL", "libSDL: error loading lib " + l + ": " + e.toString());
					try
					{
						String libname = System.mapLibraryName(l);
						File libpath = new File(getFilesDir().getAbsolutePath() + "/" + libname);
						Log.i("SDL", "libSDL: loading lib " + libpath.getAbsolutePath());
						System.load(libpath.getPath());
					}
					catch( UnsatisfiedLinkError ee )
					{
						Log.i("SDL", "libSDL: error loading lib " + l + ": " + ee.toString());
						System.loadLibrary(l);
					}
				}
			}
		}
		catch ( UnsatisfiedLinkError e )
		{
			try {
				Log.i("SDL", "libSDL: Extracting APP2SD-ed libs");
				
				InputStream in = null;
				try
				{
					for( int i = 0; ; i++ )
					{
						InputStream in2 = getAssets().open("bindata" + String.valueOf(i));
						if( in == null )
							in = in2;
						else
							in = new SequenceInputStream( in, in2 );
					}
				}
				catch( IOException ee ) { }

				if( in == null )
					throw new RuntimeException("libSDL: Extracting APP2SD-ed libs failed, the .apk file packaged incorrectly");

				ZipInputStream zip = new ZipInputStream(in);

				File libDir = getFilesDir();
				try {
					libDir.mkdirs();
				} catch( SecurityException ee ) { };
				
				byte[] buf = new byte[16384];
				while(true)
				{
					ZipEntry entry = null;
					entry = zip.getNextEntry();
					/*
					if( entry != null )
						Log.i("SDL", "Extracting lib " + entry.getName());
					*/
					if( entry == null )
					{
						Log.i("SDL", "Extracting libs finished");
						break;
					}
					if( entry.isDirectory() )
					{
						File outDir = new File( libDir.getAbsolutePath() + "/" + entry.getName() );
						if( !(outDir.exists() && outDir.isDirectory()) )
							outDir.mkdirs();
						continue;
					}

					OutputStream out = null;
					String path = libDir.getAbsolutePath() + "/" + entry.getName();
					try {
						File outDir = new File( path.substring(0, path.lastIndexOf("/") ));
						if( !(outDir.exists() && outDir.isDirectory()) )
							outDir.mkdirs();
					} catch( SecurityException eeeee ) { };

					Log.i("SDL", "Saving to file '" + path + "'");

					out = new FileOutputStream( path );
					int len = zip.read(buf);
					while (len >= 0)
					{
						if(len > 0)
							out.write(buf, 0, len);
						len = zip.read(buf);
					}

					out.flush();
					out.close();
				}

				for(String l : Globals.AppLibraries)
				{
					String libname = System.mapLibraryName(l);
					File libpath = new File(libDir, libname);
					Log.i("SDL", "libSDL: loading lib " + libpath.getPath());
					System.load(libpath.getPath());
					libpath.delete();
				}
			}
			catch ( Exception ee )
			{
				Log.i("SDL", "libSDL: Error: " + ee.toString());
			}
		}

		// ----- VCMI hack -----
		String [] binaryZipNames = { "binaries-" + android.os.Build.CPU_ABI + ".zip", "binaries-" + android.os.Build.CPU_ABI2 + ".zip", "binaries.zip" };
		for(String binaryZip: binaryZipNames)
		{
			try {
				Log.i("SDL", "libSDL: Trying to extract binaries from assets " + binaryZip);
				
				InputStream in = null;
				try
				{
					for( int i = 0; ; i++ )
					{
						InputStream in2 = getAssets().open(binaryZip + String.format("%02d", i));
						if( in == null )
							in = in2;
						else
							in = new SequenceInputStream( in, in2 );
					}
				}
				catch( IOException ee )
				{
					try
					{
						if( in == null )
							in = getAssets().open(binaryZip);
					}
					catch( IOException eee ) {}
				}

				if( in == null )
					throw new RuntimeException("libSDL: Extracting binaries failed, the .apk file packaged incorrectly");

				ZipInputStream zip = new ZipInputStream(in);

				File libDir = getFilesDir();
				try {
					libDir.mkdirs();
				} catch( SecurityException ee ) { };
				
				byte[] buf = new byte[16384];
				while(true)
				{
					ZipEntry entry = null;
					entry = zip.getNextEntry();
					/*
					if( entry != null )
						Log.i("SDL", "Extracting lib " + entry.getName());
					*/
					if( entry == null )
					{
						Log.i("SDL", "Extracting binaries finished");
						break;
					}
					if( entry.isDirectory() )
					{
						File outDir = new File( libDir.getAbsolutePath() + "/" + entry.getName() );
						if( !(outDir.exists() && outDir.isDirectory()) )
							outDir.mkdirs();
						continue;
					}

					OutputStream out = null;
					String path = libDir.getAbsolutePath() + "/" + entry.getName();
					try {
						File outDir = new File( path.substring(0, path.lastIndexOf("/") ));
						if( !(outDir.exists() && outDir.isDirectory()) )
							outDir.mkdirs();
					} catch( SecurityException eeeeeee ) { };

					try {
						CheckedInputStream check = new CheckedInputStream( new FileInputStream(path), new CRC32() );
						while( check.read(buf, 0, buf.length) > 0 ) {};
						check.close();
						if( check.getChecksum().getValue() != entry.getCrc() )
						{
							File ff = new File(path);
							ff.delete();
							throw new Exception();
						}
						Log.i("SDL", "File '" + path + "' exists and passed CRC check - not overwriting it");
						continue;
					} catch( Exception eeeeee ) { }

					Log.i("SDL", "Saving to file '" + path + "'");

					out = new FileOutputStream( path );
					int len = zip.read(buf);
					while (len >= 0)
					{
						if(len > 0)
							out.write(buf, 0, len);
						len = zip.read(buf);
					}

					out.flush();
					out.close();
					Settings.nativeChmod(path, 0755);
					//String chmod[] = { "/system/bin/chmod", "0755", path };
					//Runtime.getRuntime().exec(chmod).waitFor();
				}
				break;
			}
			catch ( Exception eee )
			{
				//Log.i("SDL", "libSDL: Error: " + eee.toString());
			}
		}
		// ----- VCMI hack -----
	};

	public static void LoadApplicationLibrary(final Context context)
	{
		Settings.nativeChdir(Globals.DataDir);
		for(String l : Globals.AppMainLibraries)
		{
			try
			{
				String libname = System.mapLibraryName(l);
				File libpath = new File(context.getFilesDir().getAbsolutePath() + "/../lib/" + libname);
				Log.i("SDL", "libSDL: loading lib " + libpath.getAbsolutePath());
				System.load(libpath.getPath());
			}
			catch( UnsatisfiedLinkError e )
			{
				Log.i("SDL", "libSDL: error loading lib " + l + ": " + e.toString());
				try
				{
					String libname = System.mapLibraryName(l);
					File libpath = new File(context.getFilesDir().getAbsolutePath() + "/" + libname);
					Log.i("SDL", "libSDL: loading lib " + libpath.getAbsolutePath());
					System.load(libpath.getPath());
				}
				catch( UnsatisfiedLinkError ee )
				{
					Log.i("SDL", "libSDL: error loading lib " + l + ": " + ee.toString());
					System.loadLibrary(l);
				}
			}
		}
	}

	public int getApplicationVersion()
	{
		try {
			PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(), 0);
			return packageInfo.versionCode;
		} catch (PackageManager.NameNotFoundException e) {
			Log.i("SDL", "libSDL: Cannot get the version of our own package: " + e);
		}
		return 0;
	}

	public boolean isRunningOnOUYA()
	{
		try {
			PackageInfo packageInfo = getPackageManager().getPackageInfo("tv.ouya", 0);
			return true;
		} catch (PackageManager.NameNotFoundException e) {
		}
		return Globals.OuyaEmulation;
	}

	public boolean isCurrentOrientationHorizontal()
	{
		Display getOrient = getWindowManager().getDefaultDisplay();
		return getOrient.getWidth() >= getOrient.getHeight();
	}

	public FrameLayout getVideoLayout() { return _videoLayout; }

	static int NOTIFY_ID = 12367098; // Random ID

	public static DemoGLSurfaceView mGLView = null;
	private static AudioThread mAudioThread = null;
	private static DataDownloader downloader = null;

	private TextView _tv = null;
	private Button _btn = null;
	private LinearLayout _layout = null;
	private LinearLayout _layout2 = null;
	private Advertisement _ad = null;

	private FrameLayout _videoLayout = null;
	private EditText _screenKeyboard = null;
	private String _screenKeyboardHintMessage = null;
	static boolean keyboardWithoutTextInputShown = false;
	private boolean sdlInited = false;

	public interface TouchEventsListener
	{
		public void onTouchEvent(final MotionEvent ev);
	}

	public interface KeyEventsListener
	{
		public void onKeyEvent(final int keyCode);
	}

	public TouchEventsListener touchListener = null;
	public KeyEventsListener keyListener = null;
	boolean _isPaused = false;
	private InputMethodManager _inputManager = null;

	public LinkedList<Integer> textInput = new LinkedList<Integer> ();
	public static MainActivity instance = null;
	
	
	@Override
	public void onBackPressed() {
		if (!canOpenRetroBoxMenu) return;
		
		if (RetroBoxDialog.cancelDialog(this)) return;
		openRetroBoxMenu();
	}
	
	private void uiSelectSaveState(final boolean isLoadingState) {
		List<SaveStateInfo> list = new ArrayList<SaveStateInfo>();
		String baseName = getIntent().getStringExtra("stateDir") + "/save";
		for(int i=0; i<6; i++) {
			String fileName = baseName + "_" + i + ".state" ;
			String fileNameShot = fileName + ".png" ;
			Log.d(LOGTAG, "Reading filestate from " + fileName);
			list.add(new SaveStateInfo(new File(fileName), new File(fileNameShot)));
		}
		
		final SaveStateSelectorAdapter adapter = new SaveStateSelectorAdapter(this, list, saveSlot);
		
		Callback<Integer> callback = new Callback<Integer>() {
			boolean invalidSlot = false;
			
			@Override
			public void onResult(Integer index) {
				System.out.println("setting save slot to " + index + " loading " + isLoadingState);
				invalidSlot = isLoadingState && 
						!((SaveStateInfo)adapter.getItem(index)).exists();
				
				if (!invalidSlot) {
					saveSlot = index;
					DemoRenderer.nativeSetSaveSlot(saveSlot);
					RetroBoxDialog.cancelDialog(MainActivity.this);
				}
			}

			@Override
			public void onFinally() {
				resumeEmulation();
				if (!invalidSlot) {
					if (isLoadingState) {
						uiLoadState();
					} else {
						uiSaveState();
					}
				}
			}
		};
		
		String title =  isLoadingState ?
				getString(R.string.emu_slot_load_title) :
				getString(R.string.emu_slot_save_title);
		RetroBoxDialog.showSaveStatesDialog(this, title, adapter, callback);
	}
	
    private void openRetroBoxMenu() {
    	pauseEmulation();
    	List<ListOption> options = new ArrayList<ListOption>();
    	options.add(new ListOption("", getString(R.string.emu_opt_cancel)));
    	options.add(new ListOption("load", getString(R.string.emu_opt_state_load)));
    	options.add(new ListOption("save", getString(R.string.emu_opt_state_save)));
    	
    	if (OverlayExtra.hasExtraButtons()) {
    		options.add(new ListOption("extra", getString(R.string.emu_opt_extra_buttons)));
    	}
    	
    	options.add(new ListOption("height+", getString(R.string.emu_amiga_more_height)));
    	options.add(new ListOption("height-", getString(R.string.emu_amiga_less_height)));
    	
    	if (canSwap) {
    		options.add(new ListOption("swap", getString(R.string.emu_opt_disk_swap)));
    	}
    	
    	options.add(new ListOption("audio", "Audio Settings")); // TODO Translate
    	// options.add(new ListOption("help", getString(R.string.emu_opt_help)));
    	options.add(new ListOption("quit", getString(R.string.emu_opt_quit)));
    	
    	RetroBoxDialog.showListDialog(this, getString(R.string.emu_opt_title), options, new Callback<KeyValue>() {
			@Override
			public void onResult(KeyValue result) {
				String key = result.getKey();
				if (key.equals("load")) {
					uiSelectSaveState(true);
					return;
				} else if (key.equals("save")) {
					uiSelectSaveState(false);
					return;
				} else if (key.equals("height+")) {
					uiMoreLines();
				} else if (key.equals("height-")) {
					uiLessLines();
				} else if (key.equals("extra")) {
					uiToggleExtraButtons();
				} else if (key.equals("swap")) {
					uiSwapDisks();
				} else if (key.equals("quit")) {
					uiQuit();
				} else if (key.equals("audio")) {
					uiOpenAudioOptions();
					return;
				} else if (key.equals("help")) {
					uiHelp();
					return;
				}
				resumeEmulation();
			}

			@Override
			public void onError() {
				resumeEmulation();
			}
			
		});
	}

    protected void uiOpenAudioOptions() {
    	List<ListOption> options = new ArrayList<ListOption>();
    	options.add(new ListOption("filter", "Filter", getAudioFilterName(getActiveAudioFilter())));
    	options.add(new ListOption("separation", "Stereo Separation", getAudioStereoSeparationName(getActiveStereoSeparation())));

    	RetroBoxDialog.showListDialog(this, "Audio options", options, new Callback<KeyValue>() {

			@Override
			public void onResult(KeyValue result) {
				String option = result.getKey();
				if (option.equals("filter"))     uiOpenAudioFilterOptions();
				if (option.equals("separation")) uiOpenAudioSeparationOptions();
			}

			@Override
			public void onError() {
				openRetroBoxMenu();
			}
		});
    }
    
    protected void uiOpenAudioFilterOptions() {
    	boolean active = getActiveAudioFilter();
    	List<ListOption> options = new ArrayList<ListOption>();
    	options.add(new ListOption("enabled", getAudioFilterName(true), active?"*":""));
    	options.add(new ListOption("disabled", getAudioFilterName(false), active?"":"*"));
    	RetroBoxDialog.showListDialog(this, "Audio filter", options, new Callback<KeyValue>() {

			@Override
			public void onResult(KeyValue result) {
				String option = result.getKey();
				
				AudioThread.nativeSetFilterEnabled(option.equals("enabled"));
				saveAudioSettings();
				
				uiOpenAudioOptions();
			}
			@Override
			public void onError() {
				uiOpenAudioOptions();
			}

    	});
    }
    
    protected void uiOpenAudioSeparationOptions() {
    	
    	List<ListOption> options = new ArrayList<ListOption>();
    	StereoSeparation activeSeparation = getActiveStereoSeparation();
    	for(int i=0; i<StereoSeparation.values().length; i++) {
    		StereoSeparation separation = StereoSeparation.values()[i];
    		String activeText = separation == activeSeparation ? "*":""; 
    		options.add(new ListOption(String.valueOf(i), getAudioStereoSeparationName(separation), activeText));
    	}
    	RetroBoxDialog.showListDialog(this, "Stereo separation", options, new Callback<KeyValue>() {

			@Override
			public void onResult(KeyValue result) {
				String option = result.getKey();
				int optionIndex = Utils.str2i(option);
				
				AudioThread.nativeSetStereoSeparation(stereoSeparationValues[optionIndex]);
				saveAudioSettings();
				
				uiOpenAudioOptions();
			}
			@Override
			public void onError() {
				uiOpenAudioOptions();
			}

    	});
    }
    
    private String getAudioFilterName(boolean useFilter) {
    	// TODO Translate
    	return useFilter?"Amiga Original (Warm)":"No filter (Plain)";
    }
    
    enum StereoSeparation {Original, Medium, Smooth, Subtle};
    float stereoSeparationValues[] = {1.0f, 0.92f, 0.78f, 0.66f};
    
    private String getAudioStereoSeparationName(StereoSeparation separation) {
    	// TODO Translate
    	switch (separation) {
    	case Original: return "Original";
    	case Medium: return "Medium";
    	case Smooth: return "Smooth";
    	case Subtle: return "Subtle";
    	}
    	return "Unknown";
    }
    
    private boolean getActiveAudioFilter() {
    	return AudioThread.nativeIsFilterEnabled();
    }
    
    private StereoSeparation getActiveStereoSeparation() {
    	float separation = AudioThread.nativeGetStereoSeparation();
    	for(int i=0; i<stereoSeparationValues.length; i++) {
    		if (separation == stereoSeparationValues[i]) return StereoSeparation.values()[i];
    	}
    	return StereoSeparation.Original;
    }
    
    private SharedPreferences getAudioPreferences() {
    	return getSharedPreferences("audio", Activity.MODE_PRIVATE);
    }
    
    private void loadAudioSettings() {
    	SharedPreferences audioPreferences = getAudioPreferences();
    	boolean filterEnabled = audioPreferences.getBoolean(KEY_AUDIO_FILTER, true);
    	AudioThread.nativeSetFilterEnabled(filterEnabled);
    	
    	String sStereoSeparation = audioPreferences.getString(KEY_STEREO_SEPARATION, StereoSeparation.Smooth.name());
    	try {
    		StereoSeparation stereoSeparation = StereoSeparation.valueOf(sStereoSeparation);
    		AudioThread.nativeSetStereoSeparation(stereoSeparationValues[stereoSeparation.ordinal()]);
    	} catch (Exception e) {
    		AudioThread.nativeSetStereoSeparation(stereoSeparationValues[StereoSeparation.Smooth.ordinal()]);
    	}
    }
    
    private void saveAudioSettings() {
    	SharedPreferences audioPreferences = getAudioPreferences();
    	Editor editor = audioPreferences.edit();
    	
    	editor.putBoolean(KEY_AUDIO_FILTER, AudioThread.nativeIsFilterEnabled());
    	editor.putString(KEY_STEREO_SEPARATION, getActiveStereoSeparation().name());
    	editor.commit();
    }
    
    protected void uiHelp() {
		RetroBoxDialog.showGamepadDialogIngame(this, gamepadInfoDialog, Mapper.hasGamepads(), new SimpleCallback() {
			@Override
			public void onResult() {
				resumeEmulation();
			}
		});
    }
    
	private void uiToggleExtraButtons() {
		extraButtonsView.toggleView();
	}

	private void uiToggleOverlay() {
		overlayGamepadView.toggleView();
	}
	
	protected static void sendNativeKey(int keyCode, boolean down) {
		DemoGLSurfaceView.nativeKey(keyCode, down?1:0, 0);
	}
	
	protected void uiLoadState() {
		uiLoadState(true);
		new Handler().postDelayed(new Runnable(){
			@Override
			public void run() {
				uiLoadState(false);
				String msg = getString(R.string.emu_slot_loaded).replace("{n}", String.valueOf(saveSlot+1));
				toastMessage(msg);
			}
		}, 500);
	}

	protected void uiSaveState() {
		uiSaveState(true);
		new Handler().postDelayed(new Runnable(){
			@Override
			public void run() {
				uiSaveState(false);
				String msg = getString(R.string.emu_slot_saved).replace("{n}", String.valueOf(saveSlot+1));
				toastMessage(msg);
			}
		}, 500);
	}
	
	protected void uiSwapDisks() {
		uiSwapDisks(true);
		new Handler().postDelayed(new Runnable(){
			@Override
			public void run() {
				uiSwapDisks(false);
			}
		}, 500);
	}

	protected void uiMoreLines() {
		uiMoreLines(true);
		new Handler().postDelayed(new Runnable(){
			@Override
			public void run() {
				uiMoreLines(false);
			}
		}, 500);
	}

	protected void uiLessLines() {
		uiLessLines(true);
		new Handler().postDelayed(new Runnable(){
			@Override
			public void run() {
				uiLessLines(false);
			}
		}, 500);
	}

	protected void uiScreenshot() {
		uiScreenshot(true);
		new Handler().postDelayed(new Runnable(){
			@Override
			public void run() {
				uiScreenshot(false);
				toastMessage(getString(R.string.emu_screenshot_failed));
			}
		}, 500);
	}

	
	protected void uiLoadState(boolean down) {
		sendNativeKey(KeyEvent.KEYCODE_SHIFT_RIGHT, down);
		sendNativeKey(KeyEvent.KEYCODE_L, down);
	}
	
	protected void uiSaveState(boolean down) {
		sendNativeKey(KeyEvent.KEYCODE_SHIFT_RIGHT, down);
		sendNativeKey(KeyEvent.KEYCODE_S, down);
	}
	
	protected void uiSwapDisks(boolean down) {
		sendNativeKey(KeyEvent.KEYCODE_SHIFT_RIGHT, down);
		sendNativeKey(KeyEvent.KEYCODE_CTRL_LEFT, down);
	}
	
	protected void uiLessLines(boolean down) {
		sendNativeKey(KeyEvent.KEYCODE_F10, down);
	}
	
	protected void uiMoreLines(boolean down) {
		sendNativeKey(KeyEvent.KEYCODE_F11, down);
	}

	protected void uiScreenshot(boolean down) {
		sendNativeKey(KeyEvent.KEYCODE_SYSRQ, down);
	}

    protected void uiQuitConfirm() {
    	QuitHandler.askForQuit(this, new QuitHandlerCallback() {
			@Override
			public void onQuit() {
				uiQuit();
			}
		});
    }
	
	public void uiQuit() {
		MainActivity.instance.finish();
	}
	
	class VirtualInputDispatcher implements VirtualEventDispatcher {

		@Override
		public void sendKey(GamepadDevice gamepad, int keyCode, boolean down) {
			if (keyCode == 0) return;
			
			if (gamepad.player == 0) {
				// emulator expect BUTTON_4 to be Joystick BUTTON_0
				if (keyCode == KeyEvent.KEYCODE_BUTTON_1) keyCode = KeyEvent.KEYCODE_BUTTON_4;
			} else {
				switch (keyCode) {
				case KeyEvent.KEYCODE_DPAD_UP     : keyCode = 204; break;
				case KeyEvent.KEYCODE_DPAD_DOWN   : keyCode = 205; break;
				case KeyEvent.KEYCODE_DPAD_LEFT   : keyCode = 206; break;
				case KeyEvent.KEYCODE_DPAD_RIGHT  : keyCode = 207; break;
				case KeyEvent.KEYCODE_BUTTON_1    : keyCode = 208; break;
				case KeyEvent.KEYCODE_BUTTON_2    : keyCode = 209; break;
				}
					
			}
			// Log.d("MAPPER", "Send native key " + keyCode + ", down:" + down + ", player:" + gamepad.player);

			sendNativeKey(keyCode, down);
		}

		@Override
		public void sendMouseButton(MouseButton button, boolean down) {
			DemoGLSurfaceView.nativeMouseButtonsPressed(button.ordinal(), down?1:0);
		}

		@Override
		public boolean handleShortcut(retrobox.vinput.Mapper.ShortCut shortcut,	boolean down) {
			switch(shortcut) {
			case LOAD_STATE : if (!down) uiLoadState(); return true;
			case SAVE_STATE: if (!down) uiSaveState(); return true;
			case SWAP_DISK: if (!down) uiSwapDisks(); return true;
			case SCREENSHOT: uiScreenshot(); return true;
			case MENU : if (!down) openRetroBoxMenu(); return true;
			case EXIT: if (!down) uiQuitConfirm(); return true;
			default: return false;
			}
		}

		@Override
		public void sendAnalog(GamepadDevice gamepad, Analog index, double x, double y, double hatx, double haty) {}
	}
}

// *** HONEYCOMB / ICS FIX FOR FULLSCREEN MODE, by lmak ***
abstract class DimSystemStatusBar
{
	public static DimSystemStatusBar get()
	{
		if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.HONEYCOMB)
			return DimSystemStatusBarHoneycomb.Holder.sInstance;
		else
			return DimSystemStatusBarDummy.Holder.sInstance;
	}
	public abstract void dim(final View view);

	private static class DimSystemStatusBarHoneycomb extends DimSystemStatusBar
	{
		private static class Holder
		{
			private static final DimSystemStatusBarHoneycomb sInstance = new DimSystemStatusBarHoneycomb();
		}
		public void dim(final View view)
		{
			if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.BASE && Globals.ImmersiveMode)
				// Immersive mode, I already hear curses when system bar reappears mid-game from the slightest swipe at the bottom of the screen
				view.setSystemUiVisibility(android.view.View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | android.view.View.SYSTEM_UI_FLAG_FULLSCREEN);
			else
				view.setSystemUiVisibility(android.view.View.STATUS_BAR_HIDDEN);
	   }
	}
	private static class DimSystemStatusBarDummy extends DimSystemStatusBar
	{
		private static class Holder
		{
			private static final DimSystemStatusBarDummy sInstance = new DimSystemStatusBarDummy();
		}
		public void dim(final View view)
		{
		}
	}
}

abstract class SetLayerType
{
	public static SetLayerType get()
	{
		if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.HONEYCOMB)
			return SetLayerTypeHoneycomb.Holder.sInstance;
		else
			return SetLayerTypeDummy.Holder.sInstance;
	}
	public abstract void setLayerType(final View view);

	private static class SetLayerTypeHoneycomb extends SetLayerType
	{
		private static class Holder
		{
			private static final SetLayerTypeHoneycomb sInstance = new SetLayerTypeHoneycomb();
		}
		public void setLayerType(final View view)
		{
			view.setLayerType(android.view.View.LAYER_TYPE_NONE, null);
			//view.setLayerType(android.view.View.LAYER_TYPE_HARDWARE, null);
		}
	}
	private static class SetLayerTypeDummy extends SetLayerType
	{
		private static class Holder
		{
			private static final SetLayerTypeDummy sInstance = new SetLayerTypeDummy();
		}
		public void setLayerType(final View view)
		{
		}
	}
}

class DummyService extends Service
{
	public DummyService()
	{
		super();
	}
	@Override
	public int onStartCommand(Intent intent, int flags, int startId)
	{
		return Service.START_STICKY;
	}
	@Override
	public void onDestroy()
	{
	}
	@Override
	public IBinder onBind(Intent intent)
	{
		return null;
	}
}
